*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfmenu.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfbar AS sfmenubase OF "sfmenu.vcx" 		&& A bar in a popup
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the submenu popup for this bar
		*m: addbars		&& Add bars to the submenu popup for this bar
		*m: addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		*m: allow		&& Determine if the bar is enabled
		*m: click		&& Called when the bar is chosen
		*m: define		&& Defines the bar
		*m: evaluatevisible		&& Determines if the bar is visible or not
		*m: findbarposition		&& Finds where the bar should be placed
		*m: hide		&& Hides the bar
		*m: lmarked_assign
		*m: lvisible_assign
		*m: oimplementation_assign
		*m: refresh		&& Refreshes the bar
		*m: setenabled		&& Sets the Enabled property to the match the implementation object's
		*m: setvisible		&& Sets the Visible property to the match the implementation object's
		*m: show		&& Displays the bar
		*p: cactiveformmethod		&& The method of the active form to execute
		*p: cappobjectmethod		&& The method of the application object to execute
		*p: cappobjectname		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
		*p: cbarposition		&& A "before" or "after" bar number clause
		*p: ccaption		&& The caption for the bar
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the bar
		*p: ckeytext		&& The text for the hotkey
		*p: cmenuclauses		&& Other clauses for bar
		*p: cmrubarclass		&& The class to use for the MRU bar
		*p: cmrubarlibrary		&& The library containing the class specified in cMRUBarClass
		*p: conclickcommand		&& The command to execute when the bar is clicked
		*p: cpicturefile		&& The file name for the picture to use
		*p: cpictureresource		&& The system menu bar name for the picture to use
		*p: cpopupname		&& The name of the popup this bar belongs to
		*p: cpopupnamethis		&& The name of the popup this bar uses for submenus
		*p: cskipfor		&& The SKIP FOR clause for the bar
		*p: cstatusbartext		&& The text displayed in the status bar when this bar is highlighted
		*p: csystembar		&& The name of the VFP system menu bar if this is one of those
		*p: ldefined		&& .T. if the menu bar for this object has been defined
		*p: lenabled		&& .T. if the bar is enabled
		*p: linvert		&& .T. to make this an inverted bar
		*p: lmarked		&& .T. if the bar is marked
		*p: lmru		&& .T. to add an MRU bar at the bottom of the submenu
		*p: lspecified		&& .T. if the bar number is specified at a certain position
		*p: lvisible		&& .T. if the bar should be visible
		*p: nbarnumber		&& The number of the bar
		*p: nseparatorbarcount		&& The number of separator bars in the menu
		*p: oimplementation		&& A reference to an implementation object
		*p: oparent		&& A reference to the parent for this bar
	*</DefinedPropArrayMethod>

	PROTECTED cpopupnamethis,ldefined,lspecified,nseparatorbarcount
	cactiveformmethod = 		&& The method of the active form to execute
	cappobjectmethod = 		&& The method of the application object to execute
	cappobjectname = oApp		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
	cbarposition = 		&& A "before" or "after" bar number clause
	ccaption = 		&& The caption for the bar
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the bar
	ckeytext = 		&& The text for the hotkey
	cmenuclauses = 		&& Other clauses for bar
	cmrubarclass = SFMRUBar		&& The class to use for the MRU bar
	cmrubarlibrary = SFMenu.vcx		&& The library containing the class specified in cMRUBarClass
	conclickcommand = 		&& The command to execute when the bar is clicked
	cpicturefile = 		&& The file name for the picture to use
	cpictureresource = 		&& The system menu bar name for the picture to use
	cpopupname = 		&& The name of the popup this bar belongs to
	cpopupnamethis = 		&& The name of the popup this bar uses for submenus
	cskipfor = not This.Allow()		&& The SKIP FOR clause for the bar
	cstatusbartext = 		&& The text displayed in the status bar when this bar is highlighted
	csystembar = 		&& The name of the VFP system menu bar if this is one of those
	ldefined = .F.		&& .T. if the menu bar for this object has been defined
	lenabled = .T.		&& .T. if the bar is enabled
	linvert = .F.		&& .T. to make this an inverted bar
	lmarked = .F.		&& .T. if the bar is marked
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the submenu
	lspecified = .F.		&& .T. if the bar number is specified at a certain position
	lvisible = .T.		&& .T. if the bar should be visible
	Name = "sfbar"
	nbarnumber = 0		&& The number of the bar
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	oimplementation = .NULL.		&& A reference to an implementation object
	oparent = .NULL.		&& A reference to the parent for this bar
	_memberdata = <VFPData>
		<memberdata name="addbar" type="method" display="AddBar"/>
		<memberdata name="addbars" type="method" display="AddBars"/>
		<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
		<memberdata name="allow" type="method" display="Allow" favorites="True"/>
		<memberdata name="cactiveformmethod" type="property" display="cActiveFormMethod" favorites="True"/>
		<memberdata name="cappobjectmethod" type="property" display="cAppObjectMethod" favorites="True"/>
		<memberdata name="cappobjectname" type="property" display="cAppObjectName"/>
		<memberdata name="cbarposition" type="property" display="cBarPosition"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
		<memberdata name="ckeytext" type="property" display="cKeyText" favorites="True"/>
		<memberdata name="click" type="method" display="Click" favorites="True"/>
		<memberdata name="cmenuclauses" type="property" display="cMenuClauses" favorites="True"/>
		<memberdata name="conclickcommand" type="property" display="cOnClickCommand" favorites="True"/>
		<memberdata name="cpicturefile" type="property" display="cPictureFile" favorites="True"/>
		<memberdata name="cpictureresource" type="property" display="cPictureResource" favorites="True"/>
		<memberdata name="cpopupnamethis" type="property" display="cPopupNameThis"/>
		<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
		<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
		<memberdata name="csystembar" type="property" display="cSystemBar" favorites="True"/>
		<memberdata name="define" type="method" display="Define"/>
		<memberdata name="evaluatevisible" type="method" display="EvaluateVisible" favorites="True"/>
		<memberdata name="findbarposition" type="method" display="FindBarPosition"/>
		<memberdata name="hide" type="method" display="Hide"/>
		<memberdata name="ldefined" type="property" display="lDefined"/>
		<memberdata name="lenabled" type="property" display="lEnabled"/>
		<memberdata name="linvert" type="property" display="lInvert"/>
		<memberdata name="lmarked" type="property" display="lMarked"/>
		<memberdata name="lmarked_assign" type="method" display="lMarked_Assign"/>
		<memberdata name="lmru" type="property" display="lMRU"/>
		<memberdata name="lspecified" type="property" display="lSpecified"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
		<memberdata name="nbarnumber" type="property" display="nBarNumber"/>
		<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="init" type="event" favorites="True"/>
		<memberdata name="oparent" type="property" display="oParent"/>
		<memberdata name="cpopupname" display="cPopupName"/>
		<memberdata name="oimplementation" display="oImplementation"/>
		<memberdata name="oimplementation_assign" display="oImplementation_Assign"/>
		<memberdata name="setenabled" display="SetEnabled"/>
		<memberdata name="setvisible" display="SetVisible"/>
		<memberdata name="cmrubarclass" display="cMRUBarClass"/>
		<memberdata name="cmrubarlibrary" display="cMRUBarLibrary"/>
		</VFPData>
	
	PROCEDURE addbar		&& Adds a bar to the submenu popup for this bar
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				loBar = createobject(tcClass, lnBarNumber, .cPopupNameThis, tcName, ;
					llSpecified)
			else
				loBar = newobject(tcClass, tcLibrary, '', lnBarNumber, ;
					.cPopupNameThis, tcName, llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
			loBar.oParent = This
			.AddProperty(tcName, loBar)
		
		* Add the bar to the collection.
		
			.Add(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE allow		&& Determine if the bar is enabled
		* Abstract method
		
	ENDPROC

	PROCEDURE click		&& Called when the bar is chosen
		local lcMethod, ;
			lnPos, ;
			lcPadPath, ;
			lcBarPath, ;
			lcCommand
		with This
			do case
		
		* We have an implementation object and we're suppose to use it for execution,
		* so call its Execute method.
		
				case vartype(.oImplementation) = 'O' and ;
					not .oImplementation.lNoExecute
					.oImplementation.Execute()
		
		* If a method of the application object was specified, call it.
		
				case not empty(.cAppObjectMethod)
					lcMethod = .cAppObjectMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type(.cAppObjectName + '.Name') = 'C' and ;
						pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
						evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type(.cAppObjectName + '.Name') = 'C' ...
		
		* If a method of the active form was specified, call it.
		
				case not empty(.cActiveFormMethod)
					lcMethod = .cActiveFormMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type('_screen.ActiveForm.Name') = 'C' and ;
						pemstatus(_screen.ActiveForm, lcMethod, 5)
						evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type('_screen.ActiveForm.Name') = 'C' ...
		
		* If an command to execute was specified, call it.
		
				case not empty(.cOnClickCommand)
					lcPadPath = .oParent.cInstanceName + '.'
					lcBarPath = lcPadPath + .Name + '.'
					lcCommand = strtran(strtran(.cOnClickCommand, 'This.oParent.', ;
						lcPadPath), 'This.', lcBarPath)
					if ccCR $ lcCommand
						execscript(lcCommand)
					else
						&lcCommand
					endif ccCR $ lcCommand
			endcase
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the bar
		local lcPopupName, ;
			lcPadPath, ;
			lcBarPath, ;
			llSystemBar, ;
			lcCaption, ;
			lcBarNumber, ;
			lcSkipFor, ;
			lcBarPosition, ;
			lcBarName, ;
			lnI, ;
			loBar, ;
			lnBar, ;
			lcClauses, ;
			lcPopupNameThis
		with This
			if vartype(.oParent) = 'O'
				lcPopupName    = .cPopupName
				lcPadPath      = .oParent.cInstanceName + '.'
				.cInstanceName = lcPadPath + .Name
				lcBarPath      = .cInstanceName + '.'
		
		* Get the bar number based on whether we're a system bar or not.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
					llSystemBar = .T.
				endif empty(.cSystemBar)
		
		* Replace & with \< in the caption.
		
				lcCaption = strtran(.cCaption, '&', '\<')
		
		* Create a default status bar text if we don't have one.
		
				if empty(.cStatusBarText)
					.cStatusBarText = strtran(strtran(lcCaption, '\<'), '\')
				endif empty(.cStatusBarText)
		
		* Set the SKIP FOR for the bar.
		
				lcSkipFor = 'not ' + lcBarPath + 'lEnabled'
				if not empty(.cSkipFor)
					lcSkipFor = lcSkipFor + ' or ' + ;
						strtran(strtran(.cSkipFor, 'This.oParent.', lcPadPath), ;
							'This.', lcBarPath)
				endif not empty(.cSkipFor)
		
		* If a bar position has been defined, it may have been defined by bar name
		* rather than number, so get the appropriate bar number.
		
				lcBarPosition = ''
				if not empty(.cBarPosition)
					lcBarName = alltrim(upper(substr(.cBarPosition, 7)))
					if val(lcBarName) = 0
						for lnI = 1 to .nBarNumber - 1
							loBar = .oParent.Item(lnI)
							do case
								case not upper(loBar.Name) == lcBarName
								case empty(loBar.cSystemBar)
									lcBarPosition = trim(left(.cBarPosition, 6)) + ;
										' ' + transform(loBar.nBarNumber)
									exit
								otherwise
									lcBarPosition = trim(left(.cBarPosition, 6)) + ;
										' ' + transform(evaluate(loBar.cSystemBar))
									exit
							endcase
						next lnI
					else
						lcBarPosition = .cBarPosition
					endif val(lcBarName) = 0
		
		* If the bar position wasn't defined, see if there's another bar in our
		* position. If so, we'll use the BEFORE clause to put ourselves before that
		* one. This is needed, for example, if you refresh a bar; it's removed from the
		* menu, then readded. Without the BEFORE clause, it would be added to the end
		* because we define popups with the RELATIVE clause.
		
				else
					try
						lnBar = getbar(lcPopupName, .nBarNumber)
					catch
						lnBar = .nBarNumber
					endtry
					if lnBar <> .nBarNumber
						lcBarPosition = 'before ' + transform(lnBar)
					endif lnBar <> .nBarNumber
				endif not empty(.cBarPosition)
		
		* Set the other clauses of the DEFINE BAR command.
		
				lcClauses = .cMenuClauses + iif(empty(.cMenuClauses), '', ' ') + ;
					lcBarPosition
				if not empty(.cKey)
					lcClauses = lcClauses + ' key ' + .cKey + ", '" + .cKeyText + "'"
				endif not empty(.cKey)
				if .lInvert
					lcClauses = lcClauses + ' invert'
				endif .lInvert
				do case
					case not empty(.cPictureResource)
						lcClauses = lcClauses + ' pictres ' + .cPictureResource
					case not empty(.cPicturefile)
						lcClauses = lcClauses + " picture '" + .cPicturefile + "'"
					case not empty(.cSystemBar)
						lcClauses = lcClauses + ' pictres ' + .cSystemBar
				endcase
		
		* Define the bar.
		
				define bar &lcBarNumber of &lcPopupName prompt lcCaption ;
					message .cStatusBarText skip for &lcSkipFor &lcClauses
		
		* Mark the bar if it's supposed to be.
		
				if .lMarked
					set mark of bar &lcBarNumber of &lcPopupName to .T.
				endif .lMarked
		
		* If this isn't a system bar, call the Click method when the bar's selected.
		
				if not llSystemBar
					on selection bar &lcBarNumber of &lcPopupName &lcBarPath.Click()
				endif not llSystemBar
		
		* Now add bars to the submenu. If we have any, create the popup for it.
		
				.AddBars()
				if .Count > 0
					lcPopupNameThis = .cPopupNameThis
					define popup (.cPopupNameThis) margin relative shadow ;
						color scheme 4
					on bar &lcBarNumber of &lcPopupName activate popup &lcPopupNameThis
		
		* If this is an MRU submenu, add an MRU bar at the end.
		
					if .lMRU
						.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
					endif .lMRU
				endif .Count > 0
		
		* Flag that the menu bar has been defined.
		
				.lDefined = .T.
			endif vartype(.oParent) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE evaluatevisible		&& Determines if the bar is visible or not
		* Determine if the bar is visible.
		
		if vartype(This.oImplementation) = 'O'
			return This.oImplementation.lVisible
		else
			return This.lVisible
		endif Vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROTECTED PROCEDURE findbarposition		&& Finds where the bar should be placed
		local lnBar, ;
			loBar, ;
			lcBarNumber, ;
			llFoundBar
		with This
		
		* We'll only do this if we don't already have a bar position.
		
			if empty(.cBarPosition)
		
		* See if there are any bars before this one that are currently visible.
		
				for lnBar = .nBarNumber - 1 to 1 step -1
					loBar = .oParent.Item(lnBar)
					if vartype(loBar) = 'O' and loBar.lVisible
						if empty(loBar.cSystemBar)
							lcBarNumber = transform(loBar.nBarNumber)
						else
							lcBarNumber = transform(evaluate(loBar.cSystemBar))
						endif empty(loBar.cSystemBar)
						.cBarPosition = 'after ' + lcBarNumber
						llFoundBar    = .T.
						exit
					endif vartype(loBar) = 'O' ...
				next lnBar
		
		* If we haven't found a bar to place this one after, see if there's one we can
		* place this before.
		
				if not llFoundBar
					for lnBar = .nBarNumber + 1 to .oParent.Count
						loBar = .oParent.Item(lnBar)
						if vartype(loBar) = 'O' and loBar.lVisible
							if empty(loBar.cSystemBar)
								lcBarNumber = transform(loBar.nBarNumber)
							else
								lcBarNumber = transform(evaluate(loBar.cSystemBar))
							endif empty(loBar.cSystemBar)
							.cBarPosition = 'before ' + lcBarNumber
							exit
						endif vartype(loBar) = 'O' ...
					next lnBar
				endif not llFoundBar
			endif empty(.cBarPosition)
		endwith
		
	ENDPROC

	PROCEDURE hide		&& Hides the bar
		local lnI, ;
			loBar, ;
			lcBarNumber, ;
			lcPopupName, ;
			lcPopupNameThis
		with This
			if .lDefined
		
		* Hide any bars in the submenu if there is one.
		
				for lnI = 1 to .Count
					loBar = .Item(lnI)
					loBar.Hide()
				next lnI
		
		* Hide the bar by releasing it.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
				endif empty(.cSystemBar)
				lcPopupName = .cPopupName
				release bar &lcBarNumber of &lcPopupName
			endif .lDefined
		
		* Release our submenu popup if it exists.
		
			lcPopupNameThis = .cPopupNameThis
			if popup(lcPopupNameThis)
				release popup &lcPopupNameThis
			endif popup(lcPopupNameThis)
			.lDefined = .F.
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters tnBarNumber, ;
			tcPopupName, ;
			tcName, ;
			tlSpecified
		with This
			dodefault()
			.nBarNumber = tnBarNumber
			.cPopupName = tcPopupName
			.lSpecified = tlSpecified
			.lVisible   = .EvaluateVisible()
		
		* If a name was specified, use it.
		
			if vartype(tcName) = 'C' and not empty(tcName)
				.Name = tcName
			endif vartype(tcName) = 'C' ...
		
		* Define the popup for this bar.
		
			if empty(.cPopupNameThis)
				.cPopupNameThis = .Name
			endif empty(.cPopupNameThis)
		endwith
		
	ENDPROC

	PROCEDURE lmarked_assign
		lparameters tlValue
		local lcSetting, ;
			lcBarNumber, ;
			lcPopupName
		with This
			assert vartype(tlValue) = 'L'
			lcSetting = iif(tlValue, '.T.', '.F.')
			.lMarked  = tlValue
			if empty(.cSystemBar)
				lcBarNumber = transform(.nBarNumber)
			else
				lcBarNumber = transform(evaluate(.cSystemBar))
			endif empty(.cSystemBar)
			lcPopupname = .cPopupName
			set mark of bar &lcBarNumber of &lcPopupName to &lcSetting
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible   = tlValue
				.lSpecified = .T.	&& so when we show it, it appears in correct place
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
		
		* If this isn't a separator bar, call AdjustSeparators to avoid consecutive
		* separator bars.
		
				if lower(.Class) <> 'sfseparatorbar' and vartype(.oParent) = 'O'
					.oParent.AdjustSeparators()
				endif lower(.Class) <> 'sfseparatorbar' ...
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE oimplementation_assign
		* Set a reference to an implementation object and bind to changes to its
		* lVisible and lEnabled properties.
		
		lparameters toObject
		if vartype(toObject) = 'O'
			This.oImplementation = toObject
			bindevent(This.oImplementation, 'lVisible', This, 'SetVisible', 1)
			bindevent(This.oImplementation, 'lEnabled', This, 'SetEnabled', 1)
		endif vartype(toObject) = 'O'
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the bar
		* Refresh the bar by hiding it, re-evaluating lVisible, and showing it again.
		
		with This
			.Hide()
			.lVisible = .EvaluateVisible()
			if .lVisible
				.Show()
			endif .lVisible
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the bar by releasing it. Release each bar so our reference in it is
		* nuked and nuke our own parent reference.
		
		local lnI, ;
			loBar
		This.Hide()
		for lnI = This.Count to 1 step -1
			loBar = This.Item(lnI)
			loBar.Release()
		next lnI
		This.oParent = .NULL.
		
		* Unbind from and nuke our implementation object.
		
		if vartype(This.oImplementation) = 'O'
			unbindevents(This.oImplementation)
			This.oImplementation = .NULL.
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE setenabled		&& Sets the Enabled property to the match the implementation object's
		if vartype(This.oImplementation) = 'O'
			This.lEnabled = This.oImplementation.lEnabled
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE setvisible		&& Sets the Visible property to the match the implementation object's
		if vartype(This.oImplementation) = 'O'
			This.lVisible = This.oImplementation.lVisible
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE show		&& Displays the bar
		* If we're supposed to, call FindBarPosition to see where the bar should go,
		* then define it.
		
		local lnI, ;
			loBar
		with This
			if .lVisible and not .lDefined
				if .lSpecified or .lInvert
					.FindBarPosition()
				endif .lSpecified ...
				.Define()
			endif .lVisible ...
		
		* Display any bars in our submenu if there is one.
		
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfeditpad AS sfpad OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \<Edit
	ckey = ALT+E
	cstatusbartext = Edit text
	Name = "sfeditpad"
	
	PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		with This
			.AddBar('SFBar', 'SFMenu.vcx', 'EditUndo')
			with .EditUndo
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_UNDO'), '\<Undo')
				.cKey           = 'CTRL+Z'
				.cKeyText       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_CTRL_KEY'), 'Ctrl') + '+Z'
				.cStatusBarText = 'Reverse the most recent edit action'
				.cSystemBar     = '_med_undo'
				.cPictureFile   = 'undoxpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditRedo')
			with .EditRedo
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_REDO'), '\<Redo')
				.cKey           = 'CTRL+R'
				.cKeyText       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_CTRL_KEY'), 'Ctrl') + '+R'
				.cStatusBarText = 'Repeat the action previously reversed with Undo'
				.cSystemBar     = '_med_redo'
				.cPictureFile   = 'redoxpsmall.bmp'
			endwith
		
			.AddSeparatorBar()
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditCut')
			with .EditCut
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_CUT'), 'Cu\<t')
				.cKey           = 'CTRL+X'
				.cKeyText       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_CTRL_KEY'), 'Ctrl') + '+X'
				.cStatusBarText = 'Remove the selection and put it on the clipboard'
				.cSystemBar     = '_med_cut'
				.cPictureFile   = 'cutxpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditCopy')
			with .EditCopy
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_COPY'), '\<Copy')
				.cKey           = 'CTRL+C'
				.cKeyText       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_CTRL_KEY'), 'Ctrl') + '+C'
				.cStatusBarText = 'Copy the selection and put it on the clipboard'
				.cSystemBar     = '_med_copy'
				.cPictureFile   = 'copyxpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditPaste')
			with .EditPaste
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_PASTE'), '\<Paste')
				.cKey           = 'CTRL+V'
				.cKeyText       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_CTRL_KEY'), 'Ctrl') + '+V'
				.cStatusBarText = 'Paste the contents of the clipboard at the ' + ;
					'insertion point'
				.cSystemBar     = '_med_paste'
				.cPictureFile   = 'pastexpsmall.bmp'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditClear')
			with .EditClear
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_CLEAR'), 'Clear')
				.cStatusBarText = 'Erase the selection'
				.cSystemBar     = '_med_clear'
				.cSkipFor       = 'empty(wontop())'
			endwith
		
			.AddSeparatorBar()
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditSelectAll')
			with .EditSelectAll
				.cCaption       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('MENU_SELECT_ALL'), 'Select \<All')
				.cKey           = 'CTRL+A'
				.cKeyText       = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_CTRL_KEY'), 'Ctrl') + '+A'
				.cStatusBarText = 'Select all lines of text in the current field'
				.cSystemBar     = '_med_slcta'
			endwith
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters tcName
		if type('oLocalizer.Name') = 'C'
			This.cCaption = oLocalizer.GetLocalizedString('MENU_EDIT_PAD')
		endif type('oLocalizer.Name') = 'C'
		dodefault(tcName)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfhelptopicsbar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \<Help Topics
	ckey = F1
	ckeytext = F1
	cpicturefile = helpxpsmall.bmp
	cstatusbartext = Display Help table of contents
	csystembar = _mst_hpsch
	Name = "sfhelptopicsbar"
	
	PROCEDURE Init
		lparameters tnBarNumber, ;
			tcPopupName, ;
			tcName, ;
			tlSpecified
		if type('oLocalizer.Name') = 'C'
			This.cCaption = oLocalizer.GetLocalizedString('MENU_HELP_TOPICS')
		endif type('oLocalizer.Name') = 'C'
		return dodefault(tnBarNumber, tcPopupName, tcName, tlSpecified)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmenu AS sfmenubase OF "sfmenu.vcx" 		&& A menu
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addpad		&& Adds a pad to the menu
		*m: cinstancename_assign
		*m: definemenu		&& Defines the desired pads in the menu
		*m: refresh		&& Refreshes the display of the menu.
		*m: show		&& Displays the menu.
		*p: cformname		&& The name of a top-level form for a menu to be placed into
		*p: cinstancename		&& The name of the variable containing the reference for this object
		*p: cmenuname		&& The name of the menu
		*p: laddtosystemmenu		&& .T. to add to the VFP system menu or .F. to be a standalone menu
	*</DefinedPropArrayMethod>

	cformname = 		&& The name of a top-level form for a menu to be placed into
	cinstancename = 		&& The name of the variable containing the reference for this object
	cmenuname = _msysmenu		&& The name of the menu
	laddtosystemmenu = .F.		&& .T. to add to the VFP system menu or .F. to be a standalone menu
	Name = "sfmenu"
	_memberdata = <VFPData>
		<memberdata name="addpad" type="method" display="AddPad"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="cinstancename_assign" type="method" display="cInstanceName_Assign"/>
		<memberdata name="definemenu" type="method" display="DefineMenu"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="cformname" type="property" display="cFormName"/>
		<memberdata name="cmenuname" type="property" display="cMenuName"/>
		<memberdata name="laddtosystemmenu" display="lAddToSystemMenu"/>
		</VFPData>
	
	PROCEDURE addpad		&& Adds a pad to the menu
		lparameters tcClass, ;
			tcLibrary, ;
			tcName
		local lcName, ;
			lcClass, ;
			lcLibrary, ;
			loPad, ;
			lnCount, ;
			loOtherPad
		with This
		
		* If tcClass and tcLibrary weren't specified, use defaults.
		
			if pcount() < 3
				lcName    = tcClass
				lcClass   = 'SFPad'
				lcLibrary = 'SFMenu.vcx'
			else
				lcClass   = tcClass
				lcLibrary = tcLibrary
				lcName    = tcName
			endif pcount() < 3
		
		* Add a pad of the desired class and name to the menu.
		
			if '\' + upper(lcLibrary) $ upper(set('CLASSLIB'))
				loPad = createobject(lcClass, lcName)
			else
				loPad = newobject(lcClass, lcLibrary, '', lcName)
			endif '\' + upper(lcLibrary) $ upper(set('CLASSLIB'))
			loPad.oParent = This
			.AddProperty(lcName, loPad)
		
		* Add the pad to the collection.
		
			.Add(loPad, lcName)
			lnCount = .Count
			do case
		
		* If this is the second item in the menu, tell the first item to display BEFORE
		* this item and this item to display AFTER that item.
		
				case lnCount = 2
					loOtherPad              = .Item(1)
					loOtherPad.cPadPosition = 'before ' + lcName
					loPad.cPadPosition      = 'after '  + loOtherPad.Name
		
		* If there are more than 2 items in the menu, this item will be displayed AFTER
		* the previous one.
		
				case lnCount > 2
					loOtherPad         = .Item(lnCount - 1)
					loPad.cPadPosition = 'after ' + loOtherPad.Name
			endcase
		endwith
		return loPad
		
	ENDPROC

	PROCEDURE cinstancename_assign
		lparameters tuValue
		if This.CalledFromThisClass()
			This.cInstanceName = tuValue
		else
			error 1743, 'cInstanceName'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE definemenu		&& Defines the desired pads in the menu
		* Abstract method
		
	ENDPROC

	PROCEDURE Init
		* Save the name of the variable or property we're being instantiated into in
		* cInstanceName. We need this so we can reference the object path from a bar
		* all the way up to the menu properly.
		
		lparameter tcInstanceName
		This.cInstanceName = tcInstanceName
		dodefault()
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the display of the menu.
		* Refresh the menu by refreshing all pads and then activating it.
		
		local lnI, ;
			loPad
		with This
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Refresh()
			next lnI
			activate menu (.cMenuName) nowait
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Release each pad so our reference in it is nuked.
		
		local lnI, ;
			loPad
		for lnI = This.Count to 1 step -1
			loPad = This.Item(lnI)
			loPad.Release()
		next lnI
		
		* Clean up the menu. 
		
		if This.cMenuName = '_msysmenu'
			pop menu _MSYSMENU
		endif This.cMenuName = '_msysmenu'
		
	ENDPROC

	PROCEDURE show		&& Displays the menu.
		local lnI, ;
			loPad
		with This
		
		* If we're putting the menu in a top-level form, set cMenuName and define the
		* menu in the specified form.
		
			if empty(.cFormName) 
				push menu _MSYSMENU
				if not .lAddToSystemMenu
			    	set sysmenu to
				endif not .lAddToSystemMenu
			else 
				if .cMenuName = '_msysmenu'
					.cMenuName = sys(2015)
				endif .cMenuName = '_msysmenu'
				define menu (.cMenuName) bar in (.cFormName)
			endif empty(.cFormName) 
		
		* Define the menu if it hasn't already been.
		
			if .Count = 0
				.DefineMenu()
			endif .Count = 0
		
		* Show all the pads.
		
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Show()
			next lnI
		
		* Display the menu.
		
			set sysmenu automatic
			activate menu (.cMenuName) nowait
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmenubase AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: clear		&& Clears the collection
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*p: cerrormessage		&& The text of an error message
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lrelease		&& .T. as the object is being released
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	cerrormessage = 		&& The text of an error message
	Height = 23
	lerroroccurred = .F.		&& .T. if an error occurred
	lrelease = .F.		&& .T. as the object is being released
	Name = "sfmenubase"
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="clear" type="method" display="Clear"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFMenuBase
		* Based On:						Collection
		* Purpose:						Base class for all menu objects
		* Author:						Doug Hennig
		* Last revision:				10/06/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Add:						store upper-cased key so case-insensitive and
		*									ignore duplicate keys
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GetKey:						handle case-insensitivity
		*	Item:						return .NULL. if the item isn't found and
		*								handle case-insensitivity
		*	Remove:						handle case-insensitivity
		*
		* Custom public properties added:
		*	cErrorMessage:				the message of an error
		*	lErrorOccurred:				.T. if an error occurred
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Clear:						clears the collection
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE Add
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local lcKey
		do case
			case pcount() = 1
				dodefault(tuItem)
			case vartype(tcKey) = 'C'
				lcKey = upper(alltrim(tcKey))
				do case
					case This.GetKey(lcKey) > 0
					case pcount() = 2
						dodefault(tuItem, lcKey)
					case pcount() = 3
						dodefault(tuItem, lcKey, tuBefore)
					case pcount() = 4
						dodefault(tuItem, lcKey, tuBefore, tuAfter)
				endcase
			case pcount() = 3
				dodefault(tuItem, tcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		nodefault
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE clear		&& Clears the collection
		This.Remove(-1)
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GetKey
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex  = upper(alltrim(tuIndex))
			luReturn = dodefault(lcIndex)
		else
			luReturn = dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE Item
		lparameters tuIndex
		local luReturn, ;
			lcIndex
		luReturn = .NULL.
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				luReturn = dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			try
				luReturn = dodefault(tuIndex)
			catch
			endtry
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE Remove
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmenufunction AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: execute		&& Performs the action of a menu or toolbar function
		*p: lenabled		&& .T. if the menu or toolbar item is enabled
		*p: lnoexecute		&& .T. to use this implementation object for display (enabled and visible) but not execution
		*p: lvisible		&& .T. if the menu or toolbar item is visible
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	lenabled = .T.		&& .T. if the menu or toolbar item is enabled
	lnoexecute = .F.		&& .T. to use this implementation object for display (enabled and visible) but not execution
	lvisible = .T.		&& .T. if the menu or toolbar item is visible
	Name = "sfmenufunction"
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="execute" display="Execute"/>
		<memberdata name="lenabled" display="lEnabled"/>
		<memberdata name="lnoexecute" display="lNoExecute"/>
		<memberdata name="lvisible" display="lVisible"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2006
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			llCOMMode, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		llCOMMode = inlist(_VFP.StartMode, 2, 3, 5)
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* If we're not running in a COM server, display a generic dialog box with an
		* option to display the debugger (this should only occur in a test
		* environment).
		
			case not llCOMMode
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Use COMRETURNERROR() if we're running in a COM server.
		
			case llCOMMode
				comreturnerror('', 'Error ' + lnError + ' occurred in line ' + ;
					transform(lnLine) + ' of ' + lcMethod)
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE execute		&& Performs the action of a menu or toolbar function
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmrubar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	cmenuclauses = mru
	conclickcommand = This.oParent.MRUSelected()
	Name = "sfmrubar"

ENDDEFINE

DEFINE CLASS sfpad AS sfmenubase OF "sfmenu.vcx" 		&& A pad in a menu
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the popup for this pad
		*m: addbars		&& Add bars to the popup attached to this pad
		*m: addseparatorbar		&& Adds a separator bar to the menu
		*m: adjustseparators		&& Adjusts the separator bars so there aren't two consecutive nor is one at the top or bottom of the menu
		*m: define		&& Defines the pad
		*m: definepad		&& Define the pad
		*m: definepopup		&& Defines the popup for the pad
		*m: hide		&& Hide the pad
		*m: lvisible_assign
		*m: mruselected		&& Called when the MRU bar is clicked
		*m: onpad		&& Called from DefinePad to define what to do when the pad is selected
		*m: refresh		&& Refreshes the pad
		*m: show		&& Shows the pad
		*p: ccaption		&& The caption for the menu pad
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the pad
		*p: cmrubarclass		&& The class to use for the MRU bar
		*p: cmrubarlibrary		&& The library containing the class specified in cMRUBarClass
		*p: cpadposition		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
		*p: cpopupname		&& The name of the popup attached to this pad
		*p: cskipfor		&& The logical expression used for the SKIP FOR clause
		*p: cstatusbartext		&& Text displayed in the status bar when this pad is highlighted
		*p: ldefined		&& .T. if the pad and popup for this object have been defined
		*p: lmru		&& .T. to add an MRU bar at the bottom of the menu
		*p: lpaddefined		&& .T. if the pad has been defined
		*p: lvisible		&& .T. if the pad is visible
		*p: nseparatorbarcount		&& The number of separator bars in the menu
		*p: oparent		&& A reference to the parent for this pad
	*</DefinedPropArrayMethod>

	PROTECTED ldefined,lpaddefined,nseparatorbarcount
	ccaption = 		&& The caption for the menu pad
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the pad
	cmrubarclass = SFMRUBar		&& The class to use for the MRU bar
	cmrubarlibrary = SFMenu.vcx		&& The library containing the class specified in cMRUBarClass
	cpadposition = 		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
	cpopupname = 		&& The name of the popup attached to this pad
	cskipfor = 		&& The logical expression used for the SKIP FOR clause
	cstatusbartext = 		&& Text displayed in the status bar when this pad is highlighted
	ldefined = .F.		&& .T. if the pad and popup for this object have been defined
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the menu
	lpaddefined = .F.		&& .T. if the pad has been defined
	lvisible = .T.		&& .T. if the pad is visible
	Name = "sfpad"
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	oparent = .NULL.		&& A reference to the parent for this pad
	_memberdata = <VFPData>
		<memberdata name="addbar" type="method" display="AddBar"/>
		<memberdata name="addbars" type="method" display="AddBars" favorites="True"/>
		<memberdata name="addseparatorbar" type="method" display="AddSeparatorBar"/>
		<memberdata name="ccaption" type="property" display="cCaption" favorites="True"/>
		<memberdata name="cinstancename" type="property" display="cInstanceName"/>
		<memberdata name="ckey" type="property" display="cKey" favorites="True"/>
		<memberdata name="cmrubarclass" type="property" display="cMRUBarClass"/>
		<memberdata name="cmrubarlibrary" type="property" display="cMRUBarLibrary"/>
		<memberdata name="cpadposition" type="property" display="cPadPosition"/>
		<memberdata name="cskipfor" type="property" display="cSkipFor" favorites="True"/>
		<memberdata name="cstatusbartext" type="property" display="cStatusBarText" favorites="True"/>
		<memberdata name="define" type="method" display="Define"/>
		<memberdata name="definepad" type="method" display="DefinePad"/>
		<memberdata name="definepopup" type="method" display="DefinePopup"/>
		<memberdata name="hide" type="method" display="Hide"/>
		<memberdata name="ldefined" type="property" display="lDefined"/>
		<memberdata name="lmru" type="property" display="lMRU" favorites="True"/>
		<memberdata name="lpaddefined" type="property" display="lPadDefined"/>
		<memberdata name="lvisible" type="property" display="lVisible"/>
		<memberdata name="lvisible_assign" type="method" display="lVisible_Assign"/>
		<memberdata name="mruselected" type="method" display="MRUSelected"/>
		<memberdata name="nseparatorbarcount" type="property" display="nSeparatorBarCount"/>
		<memberdata name="refresh" type="method" display="Refresh"/>
		<memberdata name="show" type="method" display="Show"/>
		<memberdata name="init" type="event" favorites="True"/>
		<memberdata name="oparent" type="property" display="oParent"/>
		<memberdata name="cpopupname" display="cPopupName"/>
		<memberdata name="adjustseparators" display="AdjustSeparators"/>
		<memberdata name="onpad" display="OnPad"/>
		</VFPData>
	
	PROCEDURE addbar		&& Adds a bar to the popup for this pad
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lcClass, ;
			lcLibrary, ;
			lcName, ;
			lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* If tcClass and tcLibrary weren't specified, use defaults.
		
			if pcount() < 3
				lcName      = tcClass
				lnBarNumber = tcLibrary
				lcClass     = 'SFBar'
				lcLibrary   = 'SFMenu.vcx'
			else
				lcClass     = tcClass
				lcLibrary   = tcLibrary
				lcName      = tcName
				lnBarNumber = tnBarNumber
			endif pcount() < 3
		
		* Create a bar number if one wasn't passed.
		
			if vartype(lnBarNumber) = 'N' and lnBarNumber <> 0
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member.
		
			if '\' + upper(lcLibrary) $ upper(set('CLASSLIB'))
				loBar = createobject(lcClass, lnBarNumber, .cPopupName, lcName, ;
					llSpecified)
			else
				loBar = newobject(lcClass, lcLibrary, '', lnBarNumber, .cPopupName, ;
					lcName, llSpecified)
			endif '\' + upper(lcLibrary) $ upper(set('CLASSLIB'))
			loBar.oParent = This
			.AddProperty(lcName, loBar)
		
		* Add the bar to the collection.
		
			.Add(loBar, lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE addbars		&& Add bars to the popup attached to this pad
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the menu
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE adjustseparators		&& Adjusts the separator bars so there aren't two consecutive nor is one at the top or bottom of the menu
		local lnBefore, ;
			lnAfter, ;
			loSeparatorLast, ;
			loItem, ;
			llSeparator
		
		* There's nothing to do if there are no separators.
		
		if This.nSeparatorBarCount = 0
			return
		endif This.nSeparatorBarCount = 0
		
		* Go through the separators, setting lVisible = .F. for any that's out of
		* place.
		
		lnBefore        = 0
		lnAfter         = 0
		loSeparatorLast = .NULL.
		for each loItem in This
			llSeparator = lower(loItem.Class) = 'sfseparatorbar'
			do case
		
		* We have a separator and there aren't any bars before this one.
		
				case llSeparator and lnBefore = 0
					loItem.lVisible = .F.
		
		* We have a separator, so make it visible and reset the counts of before and
		* after items.
		
				case llSeparator
					loItem.lVisible = .T.
					loSeparatorLast = .NULL.
					lnBefore        = 0
					lnAfter         = 0
		
		* This is a visible non-separator, so increment the number of bars before
		* separators. If we have a previous separator, increment the bars after.
		
				case loItem.lVisible
					lnBefore = lnBefore + 1
					if vartype(loSeparatorLast) = 'O'
						lnAfter = lnAfter + 1
					endif vartype(loSeparatorLast) = 'O'
			endcase
		next loItem
		
		* If there are no after items, the last separator should be invisible as well.
		
		if lnAfter = 0 and vartype(loSeparatorLast) = 'O'
			loSeparatorLast.lVisible = .F.
		endif lnAfter = 0 ...
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the pad
		with This
		
		* Get the object path and the names of the pad, menu, and popup.
		
			.cInstanceName = .oParent.cInstanceName + '.' + .Name
		
		* Create a default status bar text if we don't have one.
		
			if empty(.cStatusBarText)
				.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
			endif empty(.cStatusBarText)
		
		* Define the pad and popup if necessary, then add bars to the popup.
		
			if not .lPadDefined
				.DefinePopup()
				.DefinePad()
			endif not .lPadDefined
			.AddBars()
		
		* If this is an MRU menu, add an MRU bar at the end.
		
			if .lMRU
				.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
			endif .lMRU
		
		* Flag that the pad and popup have been defined.
		
			.lDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE definepad		&& Define the pad
		* Define the pad.
		
		local lcObjectPath, ;
			lcPadName, ;
			lcPopupName, ;
			lcPosition, ;
			lcSkipFor, ;
			lcClauses
		with This
			lcObjectPath = .cInstanceName + '.'
			lcPadName    = .Name
			lcPopupName  = .cPopupName
			lcPosition   = alltrim(.cPadPosition)
		
		* Set the SKIP FOR for the pad.
		
			if empty(.cSkipFor)
				lcSkipFor = ''
			else
				lcSkipFor = 'skip for ' + strtran(.cSkipFor, 'This.', lcObjectPath)
			endif not empty(.cSkipFor)
		
		* Set the key clauses of the DEFINE PAD command.
		
			lcClauses = ''
			if not empty(.cKey)
				lcClauses = lcClauses + ' key ' + strtran(.cKey, '"', "'")
			endif not empty(.cKey)
		
		* Define the pad.
		
		*** TODO: handle cContainerPosition and cObjectPosition for NEGOTIATE clause
			define pad &lcPadName of (.oParent.cMenuName) prompt .cCaption ;
				color scheme 3 &lcPosition &lcSkipFor message .cStatusBarText ;
				negotiate left, right &lcClauses
			.OnPad(lcPadName, lcPopupName, lcObjectPath)
		
		* Flag that the pad has been defined.
		
			.lPadDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE definepopup		&& Defines the popup for the pad
		define popup (This.cPopupName) margin relative shadow color scheme 4
		
	ENDPROC

	PROCEDURE hide		&& Hide the pad
		* Hide the pad by releasing it and its popup.
		
		local lcPadName, ;
			lcPopupName
		with This
			.lVisible    = .F.
			.lPadDefined = .F.
			lcPadName    = .Name
			lcPopupName = .cPopupName
			try
				release pad &lcPadName of (.oParent.cMenuName)
				release popup &lcPopupName
			catch
			endtry
		endwith
		
	ENDPROC

	PROCEDURE Init
		* Define the popup for this pad if it hasn't been already.
		
		lparameters tcName
		with This
			dodefault()
			if vartype(tcName) = 'C' and not empty(tcName)
				.Name = tcName
			endif vartype(tcName) = 'C' ...
			if empty(.cPopupName)
				.cPopupName = sys(2015)
			endif empty(.cPopupName)
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible = tlValue
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE mruselected		&& Called when the MRU bar is clicked
		local lnI, ;
			loBar, ;
			lcPopupName
		with This
		
		* Hide the MRU bar, then show all inverted bars.
		
			.MRUBar.Hide()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Show()
				endif loBar.lInvert
			next lnI
		
		* Display the popup again.
		
			lcPopupName = .cPopupName
			activate popup &lcPopupName
		
		* Now that the popup is closed, show the MRU bar and hide all inverted bars.
		
			.MRUBar.Show()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE onpad		&& Called from DefinePad to define what to do when the pad is selected
		lparameters tcPadName, ;
			tcPopupName, ;
			tcObjectPath
		on pad &tcPadName of (This.oParent.cMenuName) activate popup &tcPopupName
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the pad
		* Refresh the pad by releasing and redefining the popup and refreshing each
		* bar.
		
		local lnI, ;
			loBar
		with This
			.Hide()
			.DefinePopup()
			.DefinePad()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				loBar.Refresh()
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the pad. Release each bar so our reference in it is nuked and nuke our
		* own parent reference.
		
		local lcPopupName, ;
			lnI, ;
			loBar
		This.Hide()
		lcPopupName = This.cPopupName
		if popup(lcPopupName)
			release popup &lcPopupName
		endif popup(lcPopupName)
		for lnI = This.Count to 1 step -1
			loBar = This.Item(lnI)
			loBar.Release()
		next lnI
		This.oParent = .NULL.
		
	ENDPROC

	PROCEDURE show		&& Shows the pad
		* Define the popup and show all bars (except inverted bars, which must be
		* hidden).
		
		local lnI, ;
			loBar
		with This
			do case
		
		* If the pad has never been defined, call Define.
		
				case not .lDefined
					.Define()
		
		* If the pad has been defined but then released, call DefinePopup and
		* DefinePad.
		
				case not .lPadDefined
					.DefinePopup()
					.DefinePad()
			endcase
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpadcommand AS sfpad OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: click		&& Called when the pad is chosen
		*m: oimplementation_assign
		*m: setenabled		&& Sets the Enabled property to the match the implementation object's
		*m: setvisible		&& Sets the Visible property to the match the implementation object's
		*p: cactiveformmethod		&& The method of the active form to execute
		*p: cappobjectmethod		&& The method of the application object to execute
		*p: cappobjectname		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
		*p: conclickcommand		&& The command to execute when the pad is clicked
		*p: oimplementation		&& A reference to an implementation object
	*</DefinedPropArrayMethod>

	cactiveformmethod = 		&& The method of the active form to execute
	cappobjectmethod = 		&& The method of the application object to execute
	cappobjectname = oApp		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
	conclickcommand = 		&& The command to execute when the pad is clicked
	Name = "sfpadcommand"
	oimplementation = .NULL.		&& A reference to an implementation object
	_memberdata = <VFPData>
		<memberdata name="click" display="Click"/>
		<memberdata name="cactiveformmethod" display="cActiveFormMethod"/>
		<memberdata name="cappobjectmethod" display="cAppObjectMethod"/>
		<memberdata name="cappobjectname" display="cAppObjectName"/>
		<memberdata name="conclickcommand" display="cOnClickCommand"/>
		<memberdata name="oimplementation" display="oImplementation"/>
		<memberdata name="oimplementation_assign" display="oImplementation_Assign"/>
		<memberdata name="setenabled" display="SetEnabled"/>
		<memberdata name="setvisible" display="SetVisible"/>
		</VFPData>
	
	PROCEDURE click		&& Called when the pad is chosen
		local lcMethod, ;
			lnPos, ;
			lcPadPath, ;
			lcBarPath, ;
			lcCommand
		with This
			do case
		
		* We have an implementation object and we're suppose to use it for execution,
		* so call its Execute method.
		
				case vartype(.oImplementation) = 'O' and ;
					not .oImplementation.lNoExecute
					.oImplementation.Execute()
		
		* If a method of the application object was specified, call it.
		
				case not empty(.cAppObjectMethod)
					lcMethod = .cAppObjectMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type(.cAppObjectName + '.Name') = 'C' and ;
						pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
						evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type(.cAppObjectName + '.Name') = 'C' ...
		
		* If a method of the active form was specified, call it.
		
				case not empty(.cActiveFormMethod)
					lcMethod = .cActiveFormMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type('_screen.ActiveForm.Name') = 'C' and ;
						pemstatus(_screen.ActiveForm, lcMethod, 5)
						evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type('_screen.ActiveForm.Name') = 'C' ...
		
		* If an command to execute was specified, call it.
		
				case not empty(.cOnClickCommand)
					lcPadPath = .oParent.cInstanceName + '.'
					lcBarPath = lcPadPath + .Name + '.'
					lcCommand = strtran(strtran(.cOnClickCommand, 'This.oParent.', ;
						lcPadPath), 'This.', lcBarPath)
					if ccCR $ lcCommand
						execscript(lcCommand)
					else
						&lcCommand
					endif ccCR $ lcCommand
			endcase
		endwith
		
	ENDPROC

	PROCEDURE oimplementation_assign
		* Set a reference to an implementation object and bind to changes to its
		* lVisible and lEnabled properties.
		
		lparameters toObject
		if vartype(toObject) = 'O'
			This.oImplementation = toObject
			bindevent(This.oImplementation, 'lVisible', This, 'SetVisible', 1)
			bindevent(This.oImplementation, 'lEnabled', This, 'SetEnabled', 1)
		endif vartype(toObject) = 'O'
		
	ENDPROC

	PROCEDURE onpad
		lparameters tcPadName, ;
			tcPopupName, ;
			tcObjectPath
		on selection pad &tcPadName of (This.oParent.cMenuName) &tcObjectPath.Click()
		
	ENDPROC

	PROCEDURE setenabled		&& Sets the Enabled property to the match the implementation object's
		if vartype(This.oImplementation) = 'O'
			This.lEnabled = This.oImplementation.lEnabled
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

	PROCEDURE setvisible		&& Sets the Visible property to the match the implementation object's
		if vartype(This.oImplementation) = 'O'
			This.lVisible = This.oImplementation.lVisible
		endif vartype(This.oImplementation) = 'O'
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfseparatorbar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \-
	cstatusbartext = ( space(253) + '.')
	Name = "sfseparatorbar"

ENDDEFINE

DEFINE CLASS sfshortcutmenu AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a new bar to the shortcut menu
		*m: addmenubar		&& For backward compatibility
		*m: addmenuseparator		&& For backward compatibility
		*m: addseparatorbar		&& Adds a separator bar to the shortcut menu
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: clearmenu		&& Releases the existing shortcut menu
		*m: editbar		&& Changes any setting for the specified bar
		*m: findbar		&& Returns the bar number for the specified prompt
		*m: nbarcount_access
		*m: nbarcount_assign
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*m: showmenu		&& Display a shortcut menu
		*p: cerrormessage		&& The message of an error
		*p: conselection		&& The default command to execute, used when a menu bar that doesn't have a command specified is selected
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lrelease		&& .T. as the object is being released
		*p: nbarcount		&& The number of bars defined in the menu (read-only)
		*p: ncol		&& The column for the menu (leave 0 to use the default)
		*p: nrow		&& The row for the menu (leave 0 to use the default)
		*a: amenu[1,0]		&& An array of bars in the shortcut menu
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED amenu,lrelease
	cerrormessage = 		&& The message of an error
	conselection = 		&& The default command to execute, used when a menu bar that doesn't have a command specified is selected
	lerroroccurred = .F.		&& .T. if an error occurred
	lrelease = .F.		&& .T. as the object is being released
	Name = "sfshortcutmenu"
	nbarcount = 0		&& The number of bars defined in the menu (read-only)
	ncol = 0		&& The column for the menu (leave 0 to use the default)
	nrow = 0		&& The row for the menu (leave 0 to use the default)
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="cleanup" display="Cleanup"/>
		<memberdata name="release" display="Release"/>
		<memberdata name="releasemembers" display="ReleaseMembers"/>
		<memberdata name="showmenu" display="ShowMenu"/>
		<memberdata name="addbar" display="AddBar"/>
		<memberdata name="addseparatorbar" display="AddSeparatorBar"/>
		<memberdata name="clearmenu" display="ClearMenu"/>
		<memberdata name="conselection" display="cOnSelection"/>
		<memberdata name="editbar" display="EditBar"/>
		<memberdata name="findbar" display="FindBar"/>
		<memberdata name="nbarcount" display="nBarCount"/>
		<memberdata name="nbarcount_access" display="nBarCount_Access"/>
		<memberdata name="nbarcount_assign" display="nBarCount_Assign"/>
		<memberdata name="ncol" display="nCol"/>
		<memberdata name="nrow" display="nRow"/>
		<memberdata name="amenu" display="aMenu"/>
		<memberdata name="lrelease" display="lRelease"/>
		<memberdata name="cerrormessage" display="cErrorMessage"/>
		<memberdata name="lerroroccurred" display="lErrorOccurred"/>
		<memberdata name="addmenubar" display="AddMenuBar"/>
		<memberdata name="addmenuseparator" display="AddMenuSeparator"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addbar		&& Adds a new bar to the shortcut menu
		lparameters tcPrompt, ;
			tcOnSelection, ;
			tlDisabled, ;
			tcImage, ;
			tnElementNumber, ;
			tlMark, ;
			tlBold, ;
			tcClauses, ;
			tcSystemBar
		local lnIndex, ;
			lnMenuCount, ;
			lnElementNumber
		assert vartype(tcPrompt) = 'O' or not empty(tcPrompt) ;
			message 'SFShortcutMenu.AddBar: invalid tcPrompt'
		with This
		
		* If we were passed a reference to another menu, we'll create a submenu from
		* it.
		
			if vartype(tcPrompt) = 'O'
				for lnIndex = 1 to alen(tcPrompt.aMenu, 1)
					.AddBar(tcPrompt.aMenu[lnIndex, 1], tcPrompt.aMenu[lnIndex, 2], ;
						tcPrompt.aMenu[lnIndex, 3])
				next lnIndex
		
		* Find the next open spot in the menu array.
		
			else
				lnMenuCount = alen(.aMenu, 1)
				lnMenuCount = iif(lnMenuCount = 1 and empty(.aMenu[1]), 0, ;
					lnMenuCount) + 1
				lnIndex     = lnMenuCount
				dimension .aMenu[lnIndex, 8]
		
		* If the menu item number was passed, we'll add the menu item at that spot in
		* the menu.
		
				if vartype(tnElementNumber) = 'N'
					lnElementNumber = max(int(tnElementNumber), 1)
					if lnElementNumber < lnMenuCount
						if ains(.aMenu, lnElementNumber) = 1
							lnIndex = lnElementNumber
						endif ains(.aMenu, lnElementNumber) = 1
					endif lnElementNumber < lnMenuCount
				endif vartype(tnElementNumber) = 'N'
		
		* Put the menu item information into the array.
		
				.aMenu[lnIndex, 1] = tcPrompt
				.aMenu[lnIndex, 2] = tcOnSelection
				.aMenu[lnIndex, 3] = tcClauses
				.aMenu[lnIndex, 4] = transform(tlMark)
				.aMenu[lnIndex, 5] = transform(tlDisabled)
				.aMenu[lnIndex, 6] = transform(tlBold)
				.aMenu[lnIndex, 7] = tcImage
				.aMenu[lnIndex, 8] = tcSystemBar
			endif vartype(tcPrompt) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE addmenubar		&& For backward compatibility
		lparameters tcPrompt, ;
			tcOnSelection, ;
			tcClauses, ;
			tnElementNumber, ;
			tlMark, ;
			tlDisabled, ;
			tlBold, ;
			tcImage, ;
			tcSystemBar
		return This.AddBar(tcPrompt, tcOnSelection, tlDisabled, tcImage, ;
			tnElementNumber, tlMark, tlBold, tcClauses, tcSystemBar)
		
	ENDPROC

	PROCEDURE addmenuseparator		&& For backward compatibility
		lparameters tnElementNumber
		This.AddSeparatorBar(tnElementNumber)
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the shortcut menu
		lparameters tnElementNumber
		This.AddBar('\-', , , , tnElementNumber)
		
	ENDPROC

	PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	03/24/99
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE clearmenu		&& Releases the existing shortcut menu
		with This
			dimension .aMenu[1]
			.aMenu        = ''
			.cOnSelection = ''
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE editbar		&& Changes any setting for the specified bar
		lparameters tnBar, ;
			tcPrompt, ;
			tcOnSelection, ;
			tcDisabled, ;
			tcImage, ;
			tcMark, ;
			tcBold, ;
			tcClauses, ;
			tcSystemBar
		local lcPrompt, ;
			lcOnSelection, ;
			lcClauses, ;
			lcMark, ;
			lcDisabled, ;
			lcBold, ;
			lcImage, ;
			lcSystemBar
		with This
			assert vartype(tnBar) $ 'NFIBY' and between(tnBar, 1, .nBarCount)
		
		* Get either the existing or the new value, depending on what was passed.
		
			lcPrompt      = iif(vartype(tcPrompt)      = 'C' and ;
				not empty(tcPrompt),      tcPrompt,      .aMenu[tnBar, 1])
			lcOnSelection = iif(vartype(tcOnSelection) = 'C' and ;
				not empty(tcOnSelection), tcOnSelection, .aMenu[tnBar, 2])
			lcClauses     = iif(vartype(tcClauses)     = 'C' and ;
				not empty(tcClauses),     tcClauses,     .aMenu[tnBar, 3])
			lcMark        = iif(vartype(tcMark)        = 'C' and ;
				not empty(tcMark),        tcMark,        .aMenu[tnBar, 4])
			lcDisabled    = iif(vartype(tcDisabled)    = 'C' and ;
				not empty(tcDisabled),    tcDisabled,    .aMenu[tnBar, 5])
			lcBold        = iif(vartype(tcBold)        = 'C' and ;
				not empty(tcBold),        tcBold,        .aMenu[tnBar, 6])
			lcImage       = iif(vartype(tcImage)       = 'C' and ;
				not empty(tcImage),       tcImage,       .aMenu[tnBar, 7])
			lcSystemBar   = iif(vartype(tcSystemBar)   = 'C' and ;
				not empty(tcSystemBar),   tcSystemBar,   .aMenu[tnBar, 8])
		
		* Put the values into the array
		
			.aMenu[tnBar, 1] = lcPrompt
			.aMenu[tnBar, 2] = lcOnSelection
			.aMenu[tnBar, 3] = lcClauses
			.aMenu[tnBar, 4] = lcMark
			.aMenu[tnBar, 5] = lcDisabled
			.aMenu[tnBar, 6] = lcBold
			.aMenu[tnBar, 7] = lcImage
			.aMenu[tnBar, 8] = lcSystemBar
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2006
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			llCOMMode, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		llCOMMode = inlist(_VFP.StartMode, 2, 3, 5)
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* If we're not running in a COM server, display a generic dialog box with an
		* option to display the debugger (this should only occur in a test
		* environment).
		
			case not llCOMMode
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Use COMRETURNERROR() if we're running in a COM server.
		
			case llCOMMode
				comreturnerror('', 'Error ' + lnError + ' occurred in line ' + ;
					transform(lnLine) + ' of ' + lcMethod)
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE findbar		&& Returns the bar number for the specified prompt
		lparameters tcPrompt
		local lcPrompt, ;
			lnBar, ;
			lnI
		with This
			lcPrompt = upper(strtran(strtran(alltrim(tcPrompt), '\<'), '^'))
			lnBar    = 0
			for lnI = 1 to .nBarCount
				if upper(strtran(strtran(.aMenu[lnI, 1], '\<'), '^')) == lcPrompt
					lnBar = lnI
					exit
				endif upper(strtran(strtran(.aMenu[lnI, 1], '\<'), '^')) == lcPrompt
			next lnI
		endwith
		return lnBar
		
	ENDPROC

	PROCEDURE Init
		* Start with an empty menu array.
		
		This.ClearMenu()
		
	ENDPROC

	PROCEDURE nbarcount_access
		return iif(empty(This.aMenu[1]) or isnull(This.aMenu[1]), 0, ;
			alen(This.aMenu, 1))
		
	ENDPROC

	PROCEDURE nbarcount_assign
		error 1743, 'nBarCount'
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		lparameters tcParentMenu
		local lnMenuCount, ;
			loForm, ;
			lcWindow, ;
			lcWindowClause, ;
			lcMenu, ;
			llPosition, ;
			lnMRow, ;
			lnMCol, ;
			lnSkipCount, ;
			lnCount, ;
			lcMenuItem, ;
			luBar, ;
			llMacro, ;
			lcClauses, ;
			lcImage, ;
			llSetMark, ;
			lcMenu2, ;
			luMenuSelection
		with This
		
		* Get the number of bars in the menu. Only display the menu if it isn't empty.
		
			lnMenuCount = alen(.aMenu, 1)
			if vartype(.aMenu[1]) = 'C' and (lnMenuCount > 1 or not empty(.aMenu[1]))
		
		* Set the window to appear in.
		
				if type('_screen.ActiveForm.Name') = 'C'
					loForm = _screen.ActiveForm
				endif type('_screen.ActiveForm.Name') = 'C'
				if vartype(loForm) = 'O'
					lcWindow       = loForm.Name
					lcWindowClause = 'in window ' + lcWindow
				else
					lcWindow       = ''
					lcWindowClause = ''
				endif vartype(loForm) = 'O'
		
		* If we were passed the name of the parent menu, use it. Otherwise, create a
		* new menu name. Deactivate the menu and create a new popup if necessary.
		
				lcMenu = iif(empty(tcParentMenu), sys(2015), alltrim(tcParentMenu))
				deactivate popup (lcMenu)
				clear typeahead
				if empty(tcParentMenu)
					llPosition = .nRow <> 0 or .nCol <> 0
					if empty(lcWindow)
						lnMRow = iif(llPosition, .nRow, max(mrow(), 0))
						lnMCol = iif(llPosition, .nCol, max(mcol(), 0))
					else
						lnMRow = iif(llPosition, .nRow, max(mrow(lcWindow), 0))
						lnMCol = iif(llPosition, .nCol, max(mcol(lcWindow), 0))
					endif empty(lcWindow)
					define popup (lcMenu) from lnMRow, lnMCol &lcWindowClause margin ;
						shortcut
					on selection popup (lcMenu) deactivate menu (lcMenu)
				endif empty(tcParentMenu)
		
		* Add a bar for each menu item to the popup.
		
				lnSkipCount = 0
				for lnCount = 1 to lnMenuCount
					lcMenuItem = .aMenu[lnCount, 1]
					if left(lcMenuItem, 1) = '{'
						lcMenuItem = evaluate(substr(lcMenuItem, 2, len(lcMenuItem) - 2))
					endif left(lcMenuItem, 1) = '{'
		
		* If the item is empty or the first bar or last item is a separator, skip this
		* item.
		
					if vartype(lcMenuItem) <> 'C' or empty(lcMenuItem) or ;
						((lnCount = 1 or lnCount = lnMenuCount) and ;
						alltrim(lcMenuItem) = '\-')
						lnSkipCount = lnSkipCount + 1
						loop
					endif vartype(lcMenuItem) <> 'C' ...
		
		* Handle system bars.
		
					if not empty(.aMenu[lnCount, 8])
						luBar       = .aMenu[lnCount, 8]
						llMacro     = .T.
						lnSkipCount = lnSkipCount + 1
					else
						luBar   = lnCount - lnSkipCount
						llMacro = .F.
					endif not empty(.aMenu[lnCount, 8])
		
		* Set the clauses appropriately.
		
					if not empty(.aMenu[lnCount, 3])
						lcClauses = alltrim(.aMenu[lnCount, 3])
					else
						lcClauses = ''
					endif not empty(.aMenu[lnCount, 3])
		
		* Evaluate the mark expression (if there is one) and set the mark appropriately.
		
					if not empty(.aMenu[lnCount, 4]) and evaluate(.aMenu[lnCount, 4])
						lcMenuItem = '^' + lcMenuItem
					endif not empty(this.aMenu[lnCount, 4]) ...
		
		* Evaluate the SKIP FOR expression (if there is one) and set the clauses
		* appropriately.
		
					if not empty(.aMenu[lnCount, 5]) and evaluate(.aMenu[lnCount, 5])
						lcClauses = lcClauses + [ SKIP FOR .T.]
					endif not empty(.aMenu[lnCount, 6]) ...
		
		* Evaluate the "bold" expression (if there is one) and set the clauses
		* appropriately.
		
					if not empty(.aMenu[lnCount, 6]) and evaluate(.aMenu[lnCount, 6])
						lcClauses = lcClauses + [ STYLE "B"]
					endif not empty(.aMenu[lnCount, 6]) ...
		
		* Evaluate the image expression (if there is one) and set the clauses
		* appropriately.
		
					if not empty(.aMenu[lnCount, 7])
						lcImage = .aMenu[lnCount, 7]
						if lcImage = '_'
							lcClauses = lcClauses + ' pictres ' + lcImage
						else
							lcClauses = lcClauses + ' picture "' + lcImage + '"'
						endif lcImage = '_'
					endif not empty(.aMenu[lnCount, 7])
		
		* Handle the mark being turned on for the item.
		
					llSetMark = left(lcMenuItem,1) = '^'
					if llSetMark
						lcMenuItem = substr(lcMenuItem,2)
					endif llSetMark
		
		* Define the bar and set the mark if necessary.
		
					do case
						case empty(lcClauses) and llMacro
							define bar &luBar of (lcMenu) prompt (lcMenuItem)
						case empty(lcClauses)
							define bar luBar  of (lcMenu) prompt (lcMenuItem)
						case llMacro
							define bar &luBar of (lcMenu) prompt (lcMenuItem) ;
								&lcClauses
						otherwise
							define bar luBar  of (lcMenu) prompt (lcMenuItem) ;
								&lcClauses
					endcase
					if llSetMark
						set mark of bar luBar of (lcMenu) to .T.
					endif llSetMark
		
		* If this is a submenu, handle it.
		
					luMenuSelection = .aMenu[lnCount, 2]
					if vartype(luMenuSelection) = 'O'
						lcMenu2 = sys(2015)
						define popup (lcMenu2) margin shortcut
						on selection popup (lcMenu2) deactivate menu (lcMenu2)
						on bar lnBar of (lcMenu) activate popup (lcMenu2)
						if empty(luMenuSelection.cOnSelection)
							luMenuSelection.cOnSelection = .cOnSelection
						endif empty(luMenuSelection.cOnSelection)
						luMenuSelection.ShowMenu(lcMenu2)
						loop
					endif vartype(luMenuSelection) = 'O'
		
		* If no action was specified, use the overall one for the menu.
		
					luMenuSelection = iif(empty(luMenuSelection), ;
						alltrim(.cOnSelection), luMenuSelection)
					do case
						case empty(luMenuSelection)
						case llMacro
							on selection bar &luBar of (lcMenu) &luMenuSelection
						otherwise
							on selection bar luBar  of (lcMenu) &luMenuSelection
					endcase
				next lnCount
		
		* If there are no menu items, we're done. Otherwise, activate the menu.
		
				if lnSkipCount < lnMenuCount and empty(tcParentMenu)
					activate popup (lcMenu)
					if not empty(lcMenu)
						deactivate popup (lcMenu)
						release popup (lcMenu) extended
					endif not empty(lcMenu)
				endif lnSkipCount < lnMenuCount ...
			endif vartype(.aMenu[1]) = 'C' ...
		endwith
		
	ENDPROC

ENDDEFINE
