*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfdynamicmenu.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfdynamicmenu AS sfmenu OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: getnextitem		&& Gets the next item from the menu definition
		*p: cdelimiter		&& The delimiter character in the menu definition
		*p: cmenudefinition		&& The definition of the menu
		*p: cmenudefinitionfile		&& The file containing the menu definition
		*p: ncurrentline		&& The current line being processed in the menu definition
		*a: amenudefinition[1,0]		&& The menu definition as an array
	*</DefinedPropArrayMethod>

	cdelimiter = |		&& The delimiter character in the menu definition
	cmenudefinition = 		&& The definition of the menu
	cmenudefinitionfile = 		&& The file containing the menu definition
	Name = "sfdynamicmenu"
	ncurrentline = 0		&& The current line being processed in the menu definition
	_memberdata = <VFPData>
		<memberdata name="cmenudefinitionfile" display="cMenuDefinitionFile"/>
		<memberdata name="cmenudefinition" display="cMenuDefinition"/>
		<memberdata name="amenudefinition[1]" display="aMenuDefinition[1]"/>
		<memberdata name="amenudefinition" display="aMenuDefinition"/>
		<memberdata name="getnextitem" display="GetNextItem"/>
		<memberdata name="ncurrentline" display="nCurrentLine"/>
		<memberdata name="cdelimiter" display="cDelimiter"/>
		</VFPData>
	
	PROCEDURE definemenu
		local lcDelimiter, ;
			lnLines, ;
			laMenu[1], ;
			lcLine, ;
			lnLevel, ;
			lnI, ;
			llSeparator, ;
			lcCaption, ;
			lcName, ;
			lcClass, ;
			lcLibrary, ;
			loItem, ;
			laParents[1], ;
			lcProperty, ;
			lcPropertyName, ;
			lcPropertyValue
		
		* If a menu definition file is specified, get its content.
		
		if not empty(This.cMenuDefinitionFile) and file(This.cMenuDefinitionFile)
			This.cMenuDefinition = filetostr(This.cMenuDefinitionFile)
		endif not empty(This.cMenuDefinitionFile) ...
		
		* Split the menu definition into individual lines in This.aMenuDefinition.
		
		lcDelimiter = This.cDelimiter
		lnLines     = alines(laMenu, This.cMenuDefinition)
		dimension This.aMenuDefinition[lnLines]
		acopy(laMenu, This.aMenuDefinition)
		
		* Process each item in the definition.
		
		for This.nCurrentLine = 1 to lnLines
			lcLine = This.GetNextItem()
		
		* Strip leading tabs while counting what level we're at.
		
			lnLevel = 1
			for lnI = 1 to len(lcLine)
				if left(lcLine, 1) = ccTAB
					lnLevel = lnLevel + 1
					lcLine  = substr(lcLine, 2)
				else
					exit
				endif left(lcLine, 1) = ccTAB
			next lnI
		
		* Get the item's properties.
		
			llSeparator = .F.
			lcCaption   = strtran(strextract(lcLine, '', ccTAB, 1, 2), lcDelimiter)
			lcName      = alltrim(strtran(strextract(lcLine, 'Name',    lcDelimiter, ;
				1, 1), '='))
			lcClass     = alltrim(strtran(strextract(lcLine, 'Class',   lcDelimiter, ;
				1, 1), '='))
			lcLibrary   = alltrim(strtran(strextract(lcLine, 'Library', lcDelimiter, ;
				1, 1), '='))
		
		* If no name was specified, assign one.
		
			lcName = evl(lcName, sys(2015))
		
		* If we're at level 1, this is a pad.
		
			do case
				case lnLevel = 1
					loItem = This.AddPad(lcClass, lcLibrary, lcName)
		
		* If the caption is a dash, use a separator bar under the previous item.
		
				case lcCaption = '-'
					loItem      = laParents[lnLevel - 1].AddSeparatorBar()
					llSeparator = .T.
		
		* This is a normal bar under the previous item.
		
				otherwise
					loItem = laParents[lnLevel - 1].AddBar(lcClass, lcLibrary, lcName)
			endcase
		
		* Save the item at the appropriate level.
		
			if not llSeparator
				if lnLevel > alen(laParents)
					dimension laParents[lnLevel]
				endif lnLevel > alen(laParents)
				laParents[lnLevel] = loItem
		
		* Set the item's properties, skipping Name, Class, and Library since we already
		* handled those.
		
				loItem.cCaption = lcCaption
				lcLine = lcDelimiter + strtran(substr(lcLine, at(ccTAB, lcLine) + 1), ;
					ccTAB)
				for lnI = 1 to occurs(lcDelimiter, lcLine) - 1
					lcProperty      = strextract(lcLine, lcDelimiter, lcDelimiter, lnI)
					lcPropertyName  = lower(alltrim(strextract(lcProperty, '', '=')))
					lcPropertyValue = alltrim(strextract(lcProperty, '=', ''))
					if not empty(lcPropertyName) and ;
						not inlist(lcPropertyName, 'name', 'class', 'library')
						store lcPropertyValue to ('loItem.' + lcPropertyName)
					endif not empty(lcPropertyName) ...
				next lnI
			endif not llSeparator
		next This.nCurrentLine
		
	ENDPROC

	PROCEDURE getnextitem		&& Gets the next item from the menu definition
		* Get the current line, then append all lines that follow it if they start with
		* a delimiter.
		
		lcItem = This.aMenuDefinition[This.nCurrentLine]
		This.nCurrentLine = This.nCurrentLine + 1
		do while This.nCurrentLine <= alen(This.aMenuDefinition)
			lcLine = strtran(This.aMenuDefinition[This.nCurrentLine], ccTAB)
			if left(lcLine, 1) = This.cDelimiter
				lcItem = lcItem + ccTAB + lcLine
				This.nCurrentLine = This.nCurrentLine + 1
			else
				exit
			endif left(lcLine, 1) = This.cDelimiter
		enddo while This.nCurrentLine <= alen(This.aMenuDefinition)
		This.nCurrentLine = This.nCurrentLine - 1
		return lcItem + This.cDelimiter
		
	ENDPROC

	PROCEDURE Init
		lparameter tcInstanceName, ;
			tcMenuDefinitionFile
		dodefault(tcInstanceName)
		This.cMenuDefinitionFile = tcMenuDefinitionFile
		
	ENDPROC

	PROCEDURE refresh
		* Clear then redisplay the menu.
		
		This.Clear()
		This.Show(.T.)
		
	ENDPROC

ENDDEFINE
